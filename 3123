
    ---- –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/Kompotas/ActualLirp/refs/heads/main/Libary'))()

-- –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å
local window = library.new('ArmoriHub', 'CfgPath')
local shotgunTab = window.new_tab('http://www.roblox.com/asset/?id=15178561786')
local otherTab = window.new_tab('http://www.roblox.com/asset/?id=13321848320')
local pisun = window.new_tab('http://www.roblox.com/asset/?id=7347408509')
local section = otherTab.new_section('Visual')
local worldColorSector = section.new_sector('World Color', 'Left')
local cameraSector = section.new_sector('Visual', 'Right')
local tracerSector = section.new_sector('Tracers', 'Left')

-- üî´ Shotgun Tab Settings
local antiAimSection = pisun.new_section('AntiAim|Fov Camera')
local aaSectorBasic = antiAimSection.new_sector('Player', ' Left')
local aaSectorSettings = antiAimSection.new_sector('Settings', 'Righ')
local shotgunSection = shotgunTab.new_section('Main')
local sector1 = shotgunSection.new_sector('Silent|Settings', 'Left')
local aimbotSector = shotgunSection.new_sector('Aimbot|Settings', 'Right')

-- –í–æ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ —Ç–≤–æ—é –∫–Ω–æ–ø–∫—É
local silentAimToggle = sector1.element('Toggle', 'SilentAim', false, function(v)
      _G.HeadSize = 15
_G.Disabled = true
game:GetService('RunService').RenderStepped:connect(function()
if _G.Disabled then
for i,v in next, game:GetService('Players'):GetPlayers() do
if v.Name ~= game:GetService('Players').LocalPlayer.Name then
pcall(function()
v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize)
v.Character.Head.Transparency = 1
v.Character.Head.BrickColor = BrickColor.new("Red")
v.Character.Head.Material = "Neon"
v.Character.Head.CanCollide = false
v.Character.Head.Massless = true
end)
end
end
end
end)
end)


-- FOV CIRCLE
local fovEnabled = false
local fovSize = 100
local fovCircle = Drawing.new("Circle")
local fovColor = Color3.fromRGB(255, 255, 255)

local fovToggle = sector1.element('Toggle', 'Enable FOV', false, function(v)
    fovEnabled = v.Toggle
    fovCircle.Visible = fovEnabled
end)

fovToggle:add_color({Color = fovColor}, nil, function(v)
    fovColor = v.Color
    fovCircle.Color = fovColor
end)


local fovSlider = sector1.element('Slider', 'FOV Size', {
    default = {min = 10, max = 300, default = fovSize}
}, function(v)
    fovSize = v.Slider
    fovCircle.Radius = fovSize
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if fovEnabled and fovCircle then
        local mousePos = game:GetService("UserInputService"):GetMouseLocation()
        fovCircle.Position = Vector2.new(mousePos.X, mousePos.Y + 36)
        fovCircle.Radius = fovSize
    end
end)

-- BULLET TRACER FULL FUNCTIONALITY IN OTHER TAB
local tracerEnabled = true  
local tracerColor = Color3.fromRGB(255, 0, 255)  -- –ò—Å–ø—Ä–∞–≤–∏–ª 274 –Ω–∞ 255, —Ç.–∫. RGB –ø—Ä–∏–Ω–∏–º–∞–µ—Ç 0‚Äì255

local tracerToggle = tracerSector.element('Toggle', 'Enable Tracers', false, function(v)
    tracerEnabled = v.Toggle
end)

tracerToggle:add_color({Color = tracerColor}, nil, function(v)
    tracerColor = v.Color
end)

local player = game:GetService("Players").LocalPlayer
local mouse = player:GetMouse()  
local runService = game:GetService("RunService")  
local UIS = game:GetService("UserInputService")  
local bulletFolder = game.Workspace:FindFirstChild("Bullets") or Instance.new("Folder", game.Workspace)  
bulletFolder.Name = "Bullets"  

local shooting = false  

-- –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞—Å—Å–µ—Ä–∞
local function createTracer(startPos, direction)  
    if not tracerEnabled then return end

    local beamPart = Instance.new("Part")  
    beamPart.Size = Vector3.new(0.22, 0.22, direction.Magnitude)  
    beamPart.Position = startPos + direction / 2  
    beamPart.Anchored = true  
    beamPart.CanCollide = false  
    beamPart.Material = Enum.Material.ForceField  
    beamPart.Color = tracerColor  
    beamPart.CFrame = CFrame.lookAt(startPos, startPos + direction)  
    beamPart.Parent = bulletFolder  

    task.delay(0.4, function()  
        beamPart:Destroy()  
    end)
end

-- –§—É–Ω–∫—Ü–∏—è —Å—Ç—Ä–µ–ª—å–±—ã
local function shoot()  
    while shooting do  
        local character = player.Character  
        if character then  
            local rootPart = character:FindFirstChild("HumanoidRootPart")  
            if rootPart then  
                local startPos = rootPart.Position  
                local mouseDirection = (mouse.Hit.Position - startPos).Unit * 1000  
                createTracer(startPos, mouseDirection)  
            end  
        end  
        task.wait(0.05)  
    end  
end  

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –≤ —Ä—É–∫–∞—Ö
local function hasTool()
    local character = player.Character
    if character then
        for _, obj in ipairs(character:GetChildren()) do
            if obj:IsA("Tool") then
                return true
            end
        end
    end
    return false
end

-- –ù–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
UIS.InputBegan:Connect(function(input, processed)  
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not processed then  
        if hasTool() then  -- –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å—Ç—å –ª–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –≤ —Ä—É–∫–∞—Ö
            shooting = true  
            shoot()  
        end
    end  
end)  

-- –û—Ç–ø—É—Å–∫–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
UIS.InputEnded:Connect(function(input, processed)  
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not processed then  
        shooting = false  
    end  
end)

-- üåç WORLD COLOR
local worldColorEnabled = false
local worldColor = Color3.fromRGB(255, 255, 255)

local function applyWorldColor()
    local lighting = game:GetService("Lighting")

    -- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–∏–ª—å—Ç—Ä, –µ—Å–ª–∏ –µ—Å—Ç—å
    for _, obj in pairs(lighting:GetChildren()) do
        if obj:IsA("ColorCorrectionEffect") and obj.Name == "WorldTint" then
            obj:Destroy()
        end
    end

    -- –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç –Ω–∞–ø—Ä—è–º—É—é
    lighting.Ambient = worldColor
    lighting.OutdoorAmbient = worldColor
    lighting.FogColor = worldColor

    -- –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º ColorCorrection
    if worldColorEnabled then
        local cc = Instance.new("ColorCorrectionEffect")
        cc.Name = "WorldTint"
        cc.TintColor = worldColor
        cc.Saturation = 1
        cc.Contrast = 0.5
        cc.Parent = lighting
    end
end

-- –°–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è
local worldColorToggle = worldColorSector.element('Toggle', 'World Color', false, function(v)
    worldColorEnabled = v.Toggle

    -- –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ —ç—Ñ—Ñ–µ–∫—Ç, –Ω–æ –ù–ï —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–≤–µ—Ç
    applyWorldColor()
end)

-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞
worldColorToggle:add_color({Color = worldColor}, nil, function(v)
    worldColor = v.Color

    -- –û–±–Ω–æ–≤–∏–º —Ü–≤–µ—Ç (–≤–∫–ª—é—á—ë–Ω –ª–∏ —ç—Ñ—Ñ–µ–∫—Ç –∏–ª–∏ –Ω–µ—Ç ‚Äî –Ω–µ –≤–∞–∂–Ω–æ)
    applyWorldColor()
end)


-- ESP –ù–ê–°–¢–†–û–ô–ö–ò

-- –ö–ù–û–ü–ö–ê –í–ö–õ/–í–´–ö–õ ESP
local espEnabled = false -- –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤—ã—à–µ —Ñ—É–Ω–∫—Ü–∏–π
local settings = {
   defaultcolor = Color3.fromRGB(255, 0, 0),
   teamcheck = false,
   teamcolor = true
}

local runService = game:GetService("RunService")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera

local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new
local tan, rad = math.tan, math.rad
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end
local wtvp = function(...) local a, b = camera:WorldToViewportPoint(...) return Vector2.new(a.X, a.Y), b, a.Z end

local espCache = {}

local function createEsp(player)
   local drawings = {
       box = newDrawing("Square"),
       boxoutline = newDrawing("Square")
   }

   drawings.box.Thickness = 1
   drawings.box.Filled = false
   drawings.box.Color = settings.defaultcolor
   drawings.box.Visible = false
   drawings.box.ZIndex = 2

   drawings.boxoutline.Thickness = 3
   drawings.boxoutline.Filled = false
   drawings.boxoutline.Color = newColor3()
   drawings.boxoutline.Visible = false
   drawings.boxoutline.ZIndex = 1

   espCache[player] = drawings
end

local function removeEsp(player)
   if espCache[player] then
       for _, obj in pairs(espCache[player]) do
           obj:Remove()
       end
       espCache[player] = nil
   end
end

local function updateEsp(player, esp)
   if not espEnabled then
       esp.box.Visible = false
       esp.boxoutline.Visible = false
       return
   end

   local character = player.Character
   if not character then
       esp.box.Visible = false
       esp.boxoutline.Visible = false
       return
   end

   local hrp = character:FindFirstChild("HumanoidRootPart")
   if not hrp then
       esp.box.Visible = false
       esp.boxoutline.Visible = false
       return
   end

   local pos, visible, depth = wtvp(hrp.Position)
   if not visible then
       esp.box.Visible = false
       esp.boxoutline.Visible = false
       return
   end

   local scale = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000
   local width, height = round(4 * scale, 6 * scale)
   local x, y = round(pos.X, pos.Y)

   esp.box.Size = Vector2.new(width, height)
   esp.box.Position = Vector2.new(x - width / 2, y - height / 2)
   esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor
   esp.box.Visible = true

   esp.boxoutline.Size = esp.box.Size
   esp.boxoutline.Position = esp.box.Position
   esp.boxoutline.Visible = true
end

-- –ø–æ–¥–∫–ª—é—á–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤
for _, plr in ipairs(players:GetPlayers()) do
   if plr ~= localPlayer then
       createEsp(plr)
   end
end

players.PlayerAdded:Connect(function(plr)
   if plr ~= localPlayer then
       createEsp(plr)
   end
end)

players.PlayerRemoving:Connect(function(plr)
   removeEsp(plr)
end)

-- –†–µ–Ω–¥–µ—Ä–∏–º, –Ω–æ —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –≤–∫–ª—é—á–µ–Ω–æ
runService:BindToRenderStep("esp_render", Enum.RenderPriority.Camera.Value, function()
   if espEnabled then
       for player, drawings in pairs(espCache) do
           if settings.teamcheck and player.Team == localPlayer.Team then continue end
           updateEsp(player, drawings)
       end
   end
end)

-- –ö–ù–û–ü–ö–ê
cameraSector.element('Toggle', 'ESP Box', false, function(v)
   espEnabled = v.Toggle

   -- –û—Ç–∫–ª—é—á–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
   if not espEnabled then
       for _, drawings in pairs(espCache) do
           drawings.box.Visible = false
           drawings.boxoutline.Visible = false
       end
   end
end)

local espToggle = cameraSector.element('Toggle', 'HP', false, function(v)
    
end)

local espToggle = cameraSector.element('Toggle', 'HP value', false, function(v)
    
end)




local aimbotToggle = aimbotSector.element('Toggle', 'Aimbot', false, function(v)
    if v.Toggle then
        local teamCheck = false
        local fov = 150
        local smoothing = 1

        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")
        local Players = game:GetService("Players")
        local Camera = workspace.CurrentCamera

        getgenv()._AIMBOT_RUNNING = true

        getgenv().aimbotLoop = RunService.RenderStepped:Connect(function()
            if not getgenv()._AIMBOT_RUNNING then return end

            local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
            local localPlayer = Players.LocalPlayer
            local character = localPlayer.Character

            if pressed and character then
                local function getClosest(cframe)
                    local ray = Ray.new(cframe.Position, cframe.LookVector).Unit
                    local target, mag = nil, math.huge

                    for _, v in pairs(Players:GetPlayers()) do
                        if v ~= localPlayer and v.Character and v.Character:FindFirstChild("Head") and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") then
                            if not teamCheck or v.Team ~= localPlayer.Team then
                                local magBuf = (v.Character.Head.Position - ray:ClosestPoint(v.Character.Head.Position)).Magnitude
                                if magBuf < mag then
                                    mag = magBuf
                                    target = v
                                end
                            end
                        end
                    end
                    return target
                end

                local curTar = getClosest(Camera.CFrame)
                if curTar then
                    local ssHeadPoint = Camera:WorldToScreenPoint(curTar.Character.Head.Position)
                    local center = Camera.ViewportSize / 2
                    local screenPos = Vector2.new(ssHeadPoint.X, ssHeadPoint.Y)

                    if (screenPos - center).Magnitude < fov then
                        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, curTar.Character.Head.Position), smoothing)
                    end
                end
            end
        end)
    else
        getgenv()._AIMBOT_RUNNING = false
        if getgenv().aimbotLoop then
            getgenv().aimbotLoop:Disconnect()
        end
    end
end)



local playerTracerEnabled = false
local playerTracerColor = Color3.fromRGB(255, 255, 255)
local tracerLines = {}

local tracerToPlayerToggle = cameraSector.element('Toggle', 'Tracer to Player', false, function(v)
    playerTracerEnabled = v.Toggle

    if not playerTracerEnabled then
        for _, line in pairs(tracerLines) do
            line.Visible = false
        end
    end
end)

tracerToPlayerToggle:add_color({Color = playerTracerColor}, nil, function(v)
    playerTracerColor = v.Color
end)

-- Create lines once for each player
for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        local line = Drawing.new("Line")
        line.Thickness = 1.5
        line.Transparency = 1
        line.Visible = false
        tracerLines[player] = line
    end
end

-- Update lines on player added
game.Players.PlayerAdded:Connect(function(player)
    if player == game.Players.LocalPlayer then return end
    local line = Drawing.new("Line")
    line.Thickness = 1.5
    line.Transparency = 1
    line.Visible = false
    tracerLines[player] = line
end)

-- Clean up on player remove
game.Players.PlayerRemoving:Connect(function(player)
    if tracerLines[player] then
        tracerLines[player]:Remove()
        tracerLines[player] = nil
    end
end)

-- Update tracer positions
game:GetService("RunService").RenderStepped:Connect(function()
    if not playerTracerEnabled then return end

    local camera = workspace.CurrentCamera
    local localPlayer = game.Players.LocalPlayer
    local center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

    for player, line in pairs(tracerLines) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local partPos, visible = camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
            if visible then
                line.From = center
                line.To = Vector2.new(partPos.X, partPos.Y)
                line.Color = playerTracerColor
                line.Visible = true
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end
end)



local aimbotToggle = aimbotSector.element('Toggle', 'Target Player', false, function(v)
end)
local aimbotToggle = aimbotSector.element('Toggle', 'Team check', false, function(v)
end)



-- –ü–ï–†–ï–ú–ï–ù–ù–´–ï
local flingEnabled = false
local flingSpeed = 50 -- –Ω–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

-- –í–ö–õ/–í–´–ö–õ —Ñ–ª–∏–Ω–≥–∞
aaSectorBasic.element('Toggle', 'Anti Aim', false, function(v)
    flingEnabled = v.Toggle
end)

-- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤—Ä–∞—â–µ–Ω–∏—è (–¥–æ 200)
aaSectorSettings.element('Slider', 'Fling Spin Speed', {
    default = {min = 10, max = 200, default = flingSpeed}
}, function(v)
    flingSpeed = v.Slider
end)

-- –°–∞–º —Ñ–ª–∏–Ω–≥-—Å–ø–∏–Ω
local player = game.Players.LocalPlayer
local function onCharacterAdded(char)
    local humanoidRootPart = char:WaitForChild("HumanoidRootPart")

    task.spawn(function()
        while char and char.Parent do
            if flingEnabled then
                humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(flingSpeed), 0)
            end
            task.wait(0.05)
        end
    end)
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
    onCharacterAdded(player.Character)
end


-- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è FOV –∫–∞–º–µ—Ä—ã
local fovCameraEnabled = false
local defaultFov = 70
local newFovValue = defaultFov

-- –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –∫–∞–º–µ—Ä—É
local currentCamera = workspace.CurrentCamera
currentCamera.FieldOfView = defaultFov

-- –ö–Ω–æ–ø–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è FOV –∫–∞–º–µ—Ä—ã
local cameraFovToggle = aaSectorSettings.element('Toggle', 'Enable FOV Camera', false, function(v)
    fovCameraEnabled = v.Toggle
    if fovCameraEnabled then
        currentCamera.FieldOfView = newFovValue
    else
        currentCamera.FieldOfView = defaultFov
    end
end)

-- –°–ª–∞–π–¥–µ—Ä –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è FOV
local cameraFovSlider = aaSectorSettings.element('Slider', 'Camera FOV Value', {
    default = {min = 30, max = 120, default = defaultFov}
}, function(v)
    newFovValue = v.Slider
    if fovCameraEnabled then
        currentCamera.FieldOfView = newFovValue
    end
end)


-- –§–ª–∞–≥ –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
local infJumpEnabled = false
local infJumpConnection

aaSectorBasic.element('Toggle', 'Inf Jump', false, function(v)
    infJumpEnabled = v.Toggle

    if infJumpEnabled then
        -- –í–∫–ª—é—á–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –ø—Ä—ã–∂–æ–∫
        infJumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
                player.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    else
        -- –í—ã–∫–ª—é—á–∞–µ–º
        if infJumpConnection then
            infJumpConnection:Disconnect()
            infJumpConnection = nil
        end
    end
end)

